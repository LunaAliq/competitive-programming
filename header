#include <bits/stdc++.h>
using namespace std;

#define REP(i, n) for(int i=0, i##_len=(n); i<i##_len; ++i)
#define RREP(i, n) for(int i=n-1; i>=0; --i)

#define MEMSET(var, val) memset((var), val, sizeof(var))

#ifdef LOCAL
  #define eprintf(...) fprintf(stderr, __VA_ARGS__)
  #define epf(...) fprintf(stderr, __VA_ARGS__)
#else
  #define eprintf(...) 42
  #define epf(...) 42
#endif

typedef long long ll;
//typedef pair<int, int> P;

template<std::uint_fast64_t mod> class modint {
private:
  using u64 = std::uint_fast64_t;
  u64 _num;
  modint set(u64 num){ _num = num % mod; return *this; }
public:
  modint(){ _num = 0; }
  modint(u64 num){ _num = num % mod; }

  modint operator= (u64 x){ return set(x % mod); }
  modint operator+ (u64 x){ return modint<mod>(_num + (x % mod)); }
  modint operator- (u64 x){
    u64 _x = (x % mod);
    if (_num >= _x) {
      return modint<mod>(_num - _x);
    } else {
      return modint<mod>(mod - _x + _num);
    }
  }
  modint operator* (u64 x){ return modint<mod>(_num * (x % mod)); }
  modint operator+=(u64 x){ return set(_num + (x % mod)); }
  modint operator-=(u64 x){ return set(_num - (x % mod)); }
  modint operator*=(u64 x){ return set(_num * (x % mod)); }
  bool operator==(u64 x){ return bool(_num == (x % mod)); }

  explicit operator u64() { return _num; }
  friend ostream& operator<<(ostream &os, const modint<mod> &x){ os << x._num; return os; }
};

template<class T>bool chmax(T &a, const T &b){
  if(a < b){
    a = b;
    return 1;
  }
  return 0;
}

template<class T>bool chmin(T &a, const T &b){
  if(b < a){
    a = b;
    return 1;
  }
  return 0;
}

int gcd(int a, int b){
  return b?gcd(b,a%b):a;
}

int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

/*
int main(){

  return 0;
}
*/
